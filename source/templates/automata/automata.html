{% from 'automata/controls.html' import controls %}
{% from 'automata/constants.html' import constants %}
{% from 'automata/modal.html' import node_modal, edge_modal %}


    {% from 'menu/modal.html' import import_modal %}
    {{ import_modal(prefix_id='1') }}

{% macro automata(prefix_id='') %}
    <div class="container">
        <h2 class="text-center mt-5"> Edição de Autômatos Finitos </h2>
        {{ controls(prefix_id=prefix_id)}}
        <div id="{{prefix_id}}-automata-container" class="bg-light border h-50vh"> </div>
        {{ node_modal(prefix_id=prefix_id) }}
        {{ edge_modal(prefix_id=prefix_id) }}
        </div>
        <div id="{{prefix_id}}-states-container" class="bg-light border states-container"> 
        </div>
    </div>

    {{ constants(prefix_id=prefix_id) }}

    <script type="text/javascript">
        const state_block = "<div class='state-block'><div class='state'>q0</div><div class='word'></div></div>";
        var global = {
            network: null,
            options: null,
            nodes: null,
            edges: null,
            initial_node: null,
            final_nodes: [],
            next_node_id: 0,

            word: "",
            branches: null,
            branch_count: 0,
            processing: true,
            curr_node: {}

        };

        function toggle_edition_mode() {
            $(BACK_BTN).toggleClass("d-none");
            $(ADD_NODE_BTN).toggleClass("d-none");
            $(ADD_EDGE_BTN).toggleClass("d-none");
        }

        $(ADD_NODE_BTN).click(() => {
            toggle_edition_mode();        
            global.network.addNodeMode();
        });
        $(ADD_EDGE_BTN).click(() => {
            toggle_edition_mode();
            global.network.addEdgeMode();
        });

        $(BACK_BTN).click(() => {
            global.network.disableEditMode();
            toggle_edition_mode();
        });

        $(REMOVE_BTN).click(() => {
            global.network.deleteSelected();
            $(REMOVE_BTN).addClass("d-none");
        });



        $(STEP_BTN).click(() => {
            next_step();
        });

        $(FAST_RUN_BTN).click(() => {
            fast_run();
        });

        $(RESET_BTN).click(() => {
            reset_automata_state();
        });

        $(WORD_FIELD).on('input', () => {
            reset_automata_state();
        });

        $(DETERMINIZE_BTN).click(() =>{
            determinize();
        });

        $(UNIFY_BTN).click(() => {
            operate(UNIFY);
        });

        $(INTERSECT_BTN).click(() => {
            operate(INTERSECT);
        });

        $(document).ready(() => {
            init_automata($(CONTAINER).get(0));
            reset_automata_state();
        });

        function init_automata(container) {
            global.nodes = new vis.DataSet([]);
            global.edges = new vis.DataSet([]);

            global.options = {
                nodes: {
                    shape: "circle",
                    widthConstraint: 50,
                    borderWidth: 3,
                    borderWidthSelected: 4,
                },
                edges:{
                    arrows: "to",
                    color: "#000000"
                },
                manipulation: {
                    enabled: false,
                    initiallyActive: true,
                    addNode: add_node,
                    addEdge: add_edge,
                    editEdge: false,
                },
                physics: {
                    enabled: false,
                    barnesHut: {
                        avoidOverlap: 0,
                    },
                    stabilization: true,
                },
            };

            global.network = new vis.Network(container, {nodes: global.nodes, edges: global.edges}, global.options);
            global.network.on("doubleClick", event => {
                if (event.nodes.length > 0) {
                    edit_node(global.nodes.get(event.nodes[0]), data => global.nodes.update(data));
                } else if (event.edges.length > 0) {
                    edit_edge(global.edges.get(event.edges[0]), data => global.edges.update(data));
                }
            });
            global.network.on("select", event => {
                if (event.nodes.length || event.edges.length)
                    $(REMOVE_BTN).removeClass("d-none");
                else 
                    $(REMOVE_BTN).addClass("d-none");
            });
            global.network.on("stabilized", () => {
                global.options.physics.enabled = false;
                global.network.setOptions(global.options);
            });
        }

        //reset automata state
        function reset_automata_state(){

            global.word = $(WORD_FIELD).val();
            global.branch_count = 1;
            global.branches = {0:{processing: true, accepted: false, curr_state: -1, curr_step: 0}};
            global.processing = true;
            global.curr_node = {};
            update_nodes();
            update_branches();

        }

        //updates branches visual user interface
        function update_branches(){
            $(STATES_PANEL).empty();
            for (var branch = 0; branch < global.branch_count; branch++) {
                var new_state = $(state_block);
                new_state.attr("id", "branch-"+branch);

                var curr_state = global.branches[branch].curr_state;
                var curr_step = global.branches[branch].curr_step;

                var processing = global.branches[branch].processing;
                var accepted = global.branches[branch].accepted;


                var remaining = global.word.substring(curr_step, global.word.length);
                
                if (curr_state == -1)
                    curr_state = global.initial_node;

                if (global.initial_node == curr_state)
                    new_state.find('.state').addClass('initial');
                    
                if (global.final_nodes.includes(curr_state)) 
                    new_state.find('.state').addClass('final');

                if (accepted) 
                    new_state.addClass('accepted');
                else if(!processing)
                    new_state.addClass('rejected');

                new_state.find('.word').text(remaining);
                new_state.find('.state').text("q"+curr_state);

                $(STATES_PANEL).append(new_state);
            }
        }

        //removes failed branches from branches object
        function remove_failed_branches(){
            var new_branch_count = 0;
            var new_branches = {};

            for (var branch = 0; branch < global.branch_count; branch++) {
                if(global.branches[branch].processing || global.branches[branch].accepted){
                    new_branches[new_branch_count] = global.branches[branch];
                    new_branch_count++;
                }
            }

            global.branches = new_branches;
            global.branch_count = new_branch_count;
        }

        function fast_run(){
                var send = {
                    word:global.word,
                    automata: export_automata()
                };

                $.ajax({
                    type: 'POST',
                    url: '/automata/fastrun',
                    data: JSON.stringify(send),
                    dataType: 'json',
                    processData: false,
                    contentType: 'application/json; charset=utf-8',
                    success: function(data) {
                        alert(data.accepted)
                    }
                })
        }

        function next_step(){

            remove_failed_branches();

            //if theres nothing else to process, returns imediatly
            var curr_branch_count = global.branch_count;
            if(!global.processing)
                return;

            global.processing = false;

            //request array
            var requests = [];

            //request states reached by the consumption of a symbol for each branch
            //ignores branches that stopped in the last processing
            for (var branch = 0; branch < curr_branch_count; branch++) {
                if(!global.branches[branch].processing)
                    continue;

                global.word = $(WORD_FIELD).val()

                //sends each branch data followed by the automata and the word
                var send = {
                    configuration: global.branches[branch], 
                    word:global.word,
                    automata: export_automata()
                };

                let curr_branch = branch;

                //stores every request
                requests.push(
                    $.ajax({
                        type: 'POST',
                        url: '/automata/step',
                        data: JSON.stringify(send),
                        dataType: 'json',
                        processData: false,
                        contentType: 'application/json; charset=utf-8',
                        success: function(data) {
                            console.log(data);
                            branching(data, curr_branch);
                        }
                    })
                );
            }

            //wait for every request of each branch to be done
            //then updates the branches
            $.when(...requests).done(function(){
                global.curr_node = {};
                for (var i = 0; i < global.branch_count; i++) {
                    if (global.branches[i].processing)
                        global.curr_node[global.branches[i].curr_state] = true;
                }
                update_nodes()
                update_branches();
            });

        }


        /*  
            records the branches reached by a given branch, identified by a branch_id
            if the branch has finished processing, record the event

            each branch is a JSON in the following format
                {integer:{processing: boolean, accepted: boolean, curr_state: integer, curr_step: integer}}
                the property name indicates a branch_id
                processing indicates if the branch haven't been accepted nor failed
                accepted indicates if the branch have been accepted or failed
                curr_state indicates the current state wich the branch is
                curr_step indicates wich caracter of the word the branch is processing
            
            overwrites the given branch
            
            data is a JSON in the following format
                {processing:boolean , accepted: boolean, next_states: integer array, next_episilon_states:  integer array}
                processing indicates if the branch haven't been accepted nor failed
                accepted indicates if the branch have been accepted or failed
                next_states contains states reached by normal transitions
                next_episilon_states contains states reached by epsilon transitions

        */
        function branching(data, branch_id){
            if(data.processing){
                global.processing = true;
                var first = true;
                var curr_step = global.branches[branch_id].curr_step;

                //records new branches
                var record_new_branches = (states, step_incrementation) => {
                    for (var i = 0; i < states.length; i++) {
                        var state_id = states[i];

                        var new_branch = {
                            processing: true, 
                            accepted: false, 
                            curr_state: state_id, 
                            curr_step: curr_step+step_incrementation
                        };

                        if(first){
                            global.branches[branch_id] = new_branch;
                            first = false
                        } else{
                            global.branches[global.branch_count] = new_branch;
                            global.branch_count+=1;
                        }
                    }
                }

                //record branches with update in its curr_step
                record_new_branches(data.next_states, 1);

                 
                //record branches with no update in its curr_step
                //(reached by epsilon transitions)
                record_new_branches(data.next_episilon_states, 0);


            } else{
                //records if the branch has stopped and if it has been accepted or not
                global.branches[branch_id].processing = false;
                global.branches[branch_id].accepted = data.accepted;
            }

        }

        //request automata determinization
        function determinize(){
            $.ajax({
                type: 'POST',
                url: '/automata/determinize',
                data: JSON.stringify({automata: export_automata()}),
                dataType: 'json',
                processData: false,
                contentType: 'application/json; charset=utf-8',
                success: function(data) {
                    console.log(data);
                    import_automata(data);
                }
            })
        }

        //request operation between two automata
        const UNIFY = 'unify';
        const INTERSECT = 'intersect';
        function operate(operation){

            var automata_1_done = $.Deferred();
            var automata_2_done = $.Deferred();

            var automata_1 = null
            var automata_2 = null


            //prompt user for first automata
            show_import_modal(data => {
                post_import('/automata/import', data, res => {
                    automata_1 = res;
                    automata_1_done.resolve();
                });
            });

            //wait first automata and prompt for second
            $.when(automata_1_done).done(()=>{
                show_import_modal(data => {
                    post_import('/automata/import', data, res => {
                        automata_2 = res;
                        automata_2_done.resolve();
                    });
                });
            });

            //wait for second automata and request unification to server
            $.when(automata_2_done).done(()=>{
                $.ajax({
                    type: 'POST',
                    url: '/automata/'+operation,
                    data: JSON.stringify({automata_1: automata_1,automata_2: automata_2}),
                    dataType: 'json',
                    processData: false,
                    contentType: 'application/json; charset=utf-8',
                    success: function(data) {
                        import_automata(data)
                        console.log(data);
                    }
                })
            });

        }

        function add_node(node_data, callback) {
            node_data.id = global.next_node_id;
            node_data.label = `q${global.next_node_id}`;
            Object.assign(node_data, DEFAULT);
            global.next_node_id++;
            callback(node_data);
            update_nodes();
            toggle_edition_mode();
        }

        function edit_node(node_data, callback) {
            delete node_data.x, node_data.y;
            $(NODE_NAME).val(node_data.label);
            $(NODE_INITIAL).prop("checked", global.initial_node == node_data.id);
            $(NODE_FINAL).prop("checked", global.final_nodes.includes(node_data.id));
            $(NODE_MODAL).one("click.edit", NODE_SAVE, () => {
                node_data.label = $(NODE_NAME).val();
                if ($(NODE_INITIAL).prop("checked")) {
                    global.initial_node = node_data.id;
                } else {
                    if (global.initial_node == node_data.id)
                        global.initial_node = null;
                }
                let index = global.final_nodes.findIndex(e => e == node_data.id);
                if ($(NODE_FINAL).prop("checked")) {
                    if (index < 0)
                        global.final_nodes.push(node_data.id);
                } else {
                    if (index >= 0)
                        global.final_nodes.splice(index, 1);
                }
                callback(node_data);
                update_nodes();
                $(NODE_MODAL).modal("hide");
            });
            $(NODE_MODAL).one("hidden.bs.modal.edit", () => $(NODE_MODAL).off(".edit"));
            $(NODE_MODAL).modal("show");
        }

        function add_edge(edge_data, callback) {
            let edges = global.edges.get({filter: e => e.from == edge_data.from && e.to == edge_data.to});
            if (edges.length > 0) {
                edit_edge(edges[0], (data) => {
                    global.edges.update(data);
                    global.network.disableEditMode();
                    toggle_edition_mode();
                });
            } else {
                edge_data.literals = [];
                edge_data.smooth = {type: 'curvedCW', roundness: 0.2};
                edit_edge(edge_data, (data) => {
                    callback(data);
                    toggle_edition_mode();
                });
            }
        }

        function edit_edge(edge_data, callback) {
            populate_edge_modal(edge_data.literals);
            $(EDGE_MODAL).one("click.edit", EDGE_SAVE, () => {
                let literals = read_edge_modal();
                if (literals.length == 0)
                    literals = ['&'];
                edge_data.literals = literals;
                edge_data.label = literals.join('\n');
                callback(edge_data);
                $(EDGE_MODAL).modal("hide");
            });
            $(EDGE_MODAL).one("hidden.bs.modal.edit", () => $(EDGE_MODAL).off(".edit"));
            $(EDGE_MODAL).modal("show");
        }

        function update_nodes() {
            let group;
            let ids = global.nodes.getIds();
            for (id of ids) {
                if (global.final_nodes.includes(id)) {
                    if (global.initial_node == id) 
                        if (global.curr_node.hasOwnProperty(id)) 
                            group = CURRENT_BOTH;
                        else
                            group = BOTH;
                    else 
                        if (global.curr_node.hasOwnProperty(id)) 
                            group = CURRENT_FINAL;
                        else
                            group = FINAL;
                } else if (global.initial_node == id) 
                    if (global.curr_node.hasOwnProperty(id)) 
                        group = CURRENT_INITIAL;
                    else
                        group = INITIAL;
                else
                    if (global.curr_node.hasOwnProperty(id)) 
                        group = CURRENT;
                    else
                        group = DEFAULT;

                global.nodes.update({id: id, ...group});
            }
        }


        function import_automata(automata) {
            global.edges.clear();
            global.nodes.clear();
            global.final_nodes = [];
            global.initial_node = null;
            global.options.physics.enabled = true;
            global.network.setOptions(global.options);
            let nodes = automata.states;
            for (node of nodes) {
                node.label = node.name;
                if (node.initial) 
                    global.initial_node = node.id;
                if (node.final)
                    global.final_nodes.push(node.id);
                delete node.name;
                delete node.initial;
                delete node.final;
            }
            global.nodes.add(nodes);
            update_nodes();
            let edges = automata.transitions;
            for (edge of edges) {
                edge.literals = edge.values;
                delete edge.values;
                edge.label = edge.literals.join("\n");
            }
            global.edges.add(edges);
        }

        function export_automata() {
            let nodes = global.nodes.get({
                fields: ["id", "label"],
            });
            for (node of nodes) {
                node.name = node.label;
                delete node.label;
                node.initial = (node.id == global.initial_node);
                node.final = (global.final_nodes.includes(node.id));
            }
            let edges = global.edges.get({
                fields: ["from", "to", "literals"]
            });
            for (edge of edges) {
                edge.values = edge.literals;
                delete edge.literals;
            }
            let automata = {
                states: nodes,
                transitions: edges,
            }
            return automata;           
        }
    </script>
{% endmacro %}