{% from 'automata/controls.html' import controls %}
{% from 'automata/constants.html' import constants %}
{% from 'automata/modal.html' import node_modal, edge_modal %}

{% macro automata(prefix_id='') %}
    <div class="container">
        <h2 class="text-center mt-5"> Edição de Autômatos Finitos </h2>
        {{ controls(prefix_id=prefix_id)}}
        <div id="{{prefix_id}}-automata-container" class="bg-light border h-50vh"> </div>
        {{ node_modal(prefix_id=prefix_id) }}
        {{ edge_modal(prefix_id=prefix_id) }}
        </div>
    </div>

    {{ constants(prefix_id=prefix_id) }}

    <script type="text/javascript">
        var global = {
            network: null,
            options: null,
            nodes: null,
            edges: null,
            initial_node: null,
            final_nodes: [],
            next_node_id: 0,

            curr_step: 0,
            curr_state: 0,
            word: "",
            level: null,
            branch_count: 0,
            processing: true,
            curr_node: {}

        };

        function toggle_edition_mode() {
            $(BACK_BTN).toggleClass("d-none");
            $(ADD_NODE_BTN).toggleClass("d-none");
            $(ADD_EDGE_BTN).toggleClass("d-none");
        }

        $(ADD_NODE_BTN).click(() => {
            toggle_edition_mode();        
            global.network.addNodeMode();
        });
        $(ADD_EDGE_BTN).click(() => {
            toggle_edition_mode();
            global.network.addEdgeMode();
        });

        $(BACK_BTN).click(() => {
            global.network.disableEditMode();
            toggle_edition_mode();
        });

        $(REMOVE_BTN).click(() => {
            global.network.deleteSelected();
            $(REMOVE_BTN).addClass("d-none");
        });



        $(STEP_BTN).click(() => {
            next_step()
        });

        $(RESET_BTN).click(() => {
            reset_automata_state()
        });

        $(WORD_FIELD).on('input', () => {
            reset_automata_state()
        });
        $(document).ready(() => {
            init_automata($(CONTAINER).get(0));
            reset_automata_state();
        });

        function init_automata(container) {
            global.nodes = new vis.DataSet([]);
            global.edges = new vis.DataSet([]);

            global.options = {
                nodes: {
                    shape: "circle",
                    widthConstraint: 50,
                    borderWidth: 3,
                    borderWidthSelected: 4,
                },
                edges:{
                    arrows: "to",
                    color: "#000000"
                },
                manipulation: {
                    enabled: false,
                    initiallyActive: true,
                    addNode: add_node,
                    addEdge: add_edge,
                    editEdge: false,
                },
                physics: {
                    enabled: false,
                    barnesHut: {
                        avoidOverlap: 0,
                    },
                    stabilization: true,
                },
            };

            global.network = new vis.Network(container, {nodes: global.nodes, edges: global.edges}, global.options);
            global.network.on("doubleClick", event => {
                if (event.nodes.length > 0) {
                    edit_node(global.nodes.get(event.nodes[0]), data => global.nodes.update(data));
                } else if (event.edges.length > 0) {
                    edit_edge(global.edges.get(event.edges[0]), data => global.edges.update(data));
                }
            });
            global.network.on("select", event => {
                if (event.nodes.length || event.edges.length)
                    $(REMOVE_BTN).removeClass("d-none");
                else 
                    $(REMOVE_BTN).addClass("d-none");
            });
            global.network.on("stabilized", () => {
                global.options.physics.enabled = false;
                global.network.setOptions(global.options);
            });
        }

        function reset_automata_state(){
            global.curr_step = 0;
            global.curr_state = 0;
            global.word = $(WORD_FIELD).val();
            $(TAIL_FIELD).val($(WORD_FIELD).val());
            global.branch_count = 1;
            global.level = {0:{processing: true, accepted: false, curr_state: -1, curr_step: 0}};
            global.processing = true;
            global.curr_node = {};
            update_nodes();

        }

        function update_tail(){
            $(TAIL_FIELD).val(global.word.substring(global.curr_step, global.word.length));
        }

        function remove_failed_branches(){
            var new_branch_count = 0;
            var new_branches = {};

            for (var branch = 0; branch < global.branch_count; branch++) {
                if(global.level[branch].processing || global.level[branch].accepted){
                    new_branches[new_branch_count] = global.level[branch];
                    new_branch_count++;
                }
            }

            global.level = new_branches;
            global.branch_count = new_branch_count;
        }

        function next_step(){

            remove_failed_branches();

            var curr_branch_count = global.branch_count;
            if(!global.processing)
                return;

            global.processing = false;

            for (var branch = 0; branch < curr_branch_count; branch++) {
                if(!global.level[branch].processing)
                    continue;

                global.word = $(WORD_FIELD).val()
                var send = {
                    configuration: global.level[branch], 
                    word:global.word,
                    automata: export_automata()
                };

                let curr_branch = branch;

                $.ajax({
                    type: 'POST',
                    url: '/automata/step',
                    data: JSON.stringify(send),
                    dataType: 'json',
                    processData: false,
                    contentType: 'application/json; charset=utf-8',
                    success: function(data) {
                        console.log(data);
                        branching(data, curr_branch);
                    }
                });
            }
            update_tail();
            global.curr_node = {};
            for (var i = 0; i < curr_branch_count; i++) {
                global.curr_node[global.level[i].curr_state] = true;
            }
            console.log(global.curr_node);
            update_nodes()

        }

        function branching(data, branch){
            if(data.processing){
                global.processing = true;
                var first = true;
                var curr_step = global.level[branch].curr_step;

                for (var i = 0; i < data.next_states.length; i++) {
                    var state_id = data.next_states[i];

                    var new_branch = {
                        processing: true, 
                        accepted: false, 
                        curr_state: state_id, 
                        curr_step: curr_step+1
                    };

                    if(first){
                        global.level[branch] = new_branch;
                        first = false
                    } else{
                        global.level[global.branch_count] = new_branch;
                        global.branch_count+=1;
                    }
                }

                for (var i = 0; i < data.next_episilon_states.length; i++) {
                    var state_id = data.next_episilon_states[i];

                    var new_branch = {
                        processing: true, 
                        accepted: false, 
                        curr_state: state_id, 
                        curr_step: curr_step
                    };

                    if(first){
                        global.level[branch] = new_branch;
                        first = false
                    } else{
                        global.level[global.branch_count] = new_branch;
                        global.branch_count+=1;
                    }
                }
            } else{
                if(data.accepted) {
                    global.level[branch].processing = false;
                    global.level[branch].accepted = true;
                } else {
                    global.level[branch].processing = false;
                    global.level[branch].accepted = false;
                }
            }

        }

        function add_node(node_data, callback) {
            node_data.id = global.next_node_id;
            node_data.label = `q${global.next_node_id}`;
            Object.assign(node_data, DEFAULT);
            global.next_node_id++;
            callback(node_data);
            update_nodes();
            toggle_edition_mode();
        }

        function edit_node(node_data, callback) {
            delete node_data.x, node_data.y;
            $(NODE_NAME).val(node_data.label);
            $(NODE_INITIAL).prop("checked", global.initial_node == node_data.id);
            $(NODE_FINAL).prop("checked", global.final_nodes.includes(node_data.id));
            $(NODE_MODAL).one("click.edit", NODE_SAVE, () => {
                node_data.label = $(NODE_NAME).val();
                if ($(NODE_INITIAL).prop("checked")) {
                    global.initial_node = node_data.id;
                } else {
                    if (global.initial_node == node_data.id)
                        global.initial_node = null;
                }
                let index = global.final_nodes.findIndex(e => e == node_data.id);
                if ($(NODE_FINAL).prop("checked")) {
                    if (index < 0)
                        global.final_nodes.push(node_data.id);
                } else {
                    if (index >= 0)
                        global.final_nodes.splice(index, 1);
                }
                callback(node_data);
                update_nodes();
                $(NODE_MODAL).modal("hide");
            });
            $(NODE_MODAL).one("hidden.bs.modal.edit", () => $(NODE_MODAL).off(".edit"));
            $(NODE_MODAL).modal("show");
        }

        function add_edge(edge_data, callback) {
            let edges = global.edges.get({filter: e => e.from == edge_data.from && e.to == edge_data.to});
            if (edges.length > 0) {
                edit_edge(edges[0], (data) => {
                    global.edges.update(data);
                    global.network.disableEditMode();
                    toggle_edition_mode();
                });
            } else {
                edge_data.literals = [];
                edge_data.smooth = {type: 'curvedCW', roundness: 0.2};
                edit_edge(edge_data, (data) => {
                    callback(data);
                    toggle_edition_mode();
                });
            }
        }

        function edit_edge(edge_data, callback) {
            populate_edge_modal(edge_data.literals);
            $(EDGE_MODAL).one("click.edit", EDGE_SAVE, () => {
                let literals = read_edge_modal();
                if (literals.length == 0)
                    literals = ['&'];
                edge_data.literals = literals;
                edge_data.label = literals.join('\n');
                callback(edge_data);
                $(EDGE_MODAL).modal("hide");
            });
            $(EDGE_MODAL).one("hidden.bs.modal.edit", () => $(EDGE_MODAL).off(".edit"));
            $(EDGE_MODAL).modal("show");
        }

        function update_nodes() {
            let group;
            let ids = global.nodes.getIds();
            for (id of ids) {
                if (global.final_nodes.includes(id)) {
                    if (global.initial_node == id) 
                        if (global.curr_node.hasOwnProperty(id)) 
                            group = CURRENT_BOTH;
                        else
                            group = BOTH;
                    else 
                        if (global.curr_node.hasOwnProperty(id)) 
                            group = CURRENT_FINAL;
                        else
                            group = FINAL;
                } else if (global.initial_node == id) 
                    if (global.curr_node.hasOwnProperty(id)) 
                        group = CURRENT_INITIAL;
                    else
                        group = INITIAL;
                else
                    if (global.curr_node.hasOwnProperty(id)) 
                        group = CURRENT;
                    else
                        group = DEFAULT;

                global.nodes.update({id: id, ...group});
            }
        }


        function import_automata(automata) {
            global.edges.clear();
            global.nodes.clear();
            global.final_nodes = [];
            global.initial_node = null;
            global.options.physics.enabled = true;
            global.network.setOptions(global.options);
            let nodes = automata.states;
            for (node of nodes) {
                node.label = node.name;
                if (node.initial) 
                    global.initial_node = node.id;
                if (node.final)
                    global.final_nodes.push(node.id);
                delete node.name;
                delete node.initial;
                delete node.final;
            }
            global.nodes.add(nodes);
            update_nodes();
            let edges = automata.transitions;
            for (edge of edges) {
                edge.literals = edge.values;
                delete edge.values;
                edge.label = edge.literals.join("\n");
            }
            global.edges.add(edges);
        }

        function export_automata() {
            let nodes = global.nodes.get({
                fields: ["id", "label"],
            });
            for (node of nodes) {
                node.name = node.label;
                delete node.label;
                node.initial = (node.id == global.initial_node);
                node.final = (global.final_nodes.includes(node.id));
            }
            let edges = global.edges.get({
                fields: ["from", "to", "literals"]
            });
            for (edge of edges) {
                edge.values = edge.literals;
                delete edge.literals;
            }
            let automata = {
                states: nodes,
                transitions: edges,
            }
            return automata;           
        }
    </script>
{% endmacro %}